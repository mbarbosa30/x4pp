Perfect ‚Äî thanks for the super-clear spec. Below is a step-by-step, wire-it-now plan tailored to your current stack and the open-bidding model you described for x4pp. It‚Äôs written so you can hand it to a dev and start implementing immediately.

‚∏ª

1) Harden the data model (Drizzle / Postgres)

Tables & key constraints
	‚Ä¢	users
	‚Ä¢	id pk, username unique, wallet_address unique not null
	‚Ä¢	min_base_price_usd numeric(12,6) not null default 0.050000
	‚Ä¢	sla_hours int not null default 24
	‚Ä¢	indexes: idx_users_username, idx_users_wallet
	‚Ä¢	messages
	‚Ä¢	id pk, sender_user_id fk, recipient_user_id fk
	‚Ä¢	content_cipher text not null (or plain text if you keep it simple for MVP)
	‚Ä¢	bid_usd numeric(12,6) not null, reply_bounty_usd numeric(12,6) null
	‚Ä¢	status enum('pending','accepted','declined','expired','withdrawn') not null
	‚Ä¢	created_at timestamptz default now()
	‚Ä¢	expires_at timestamptz not null
	‚Ä¢	accepted_at, declined_at timestamptz null
	‚Ä¢	rule: one active pending per (sender, recipient) ‚Üí unique partial index
create unique index uniq_pending_pair on messages(sender_user_id, recipient_user_id) where status='pending';
	‚Ä¢	payments
	‚Ä¢	id pk, message_id fk unique
	‚Ä¢	amount_usdc bigint not null (USDC 6 decimals; store in ‚Äúmicrounits‚Äù)
	‚Ä¢	from_address, to_address
	‚Ä¢	full EIP-3009 auth capture: valid_after bigint, valid_before bigint, nonce bytes32, v smallint, r bytes32, s bytes32
	‚Ä¢	status enum('authorized','settled','unused','refund_failed') not null
	‚Ä¢	tx_hash_auth null, tx_hash_settle null
	‚Ä¢	index: idx_payments_nonce (defense-in-depth against replay in your DB)
	‚Ä¢	blocks
	‚Ä¢	id pk, recipient_user_id fk, blocked_sender_user_id fk, created_at
	‚Ä¢	unique (recipient_user_id, blocked_sender_user_id)

(If you already have tables, just ensure the constraints and indexes above.)

‚∏ª

2) Auth & wallet binding
	‚Ä¢	When a user registers/updates wallet_address, store it and enforce at send time that:
	‚Ä¢	the EIP-3009 from in the authorization equals sender.wallet_address.
	‚Ä¢	the to equals recipient.wallet_address from DB (prevent ‚Äúwrong recipient‚Äù tricks).
	‚Ä¢	Keep session auth (HttpOnly cookie + session table). Add a simple /me to return {id, username, wallet_address, min_base_price_usd, sla_hours}.

‚∏ª

3) Price Guide API

GET /api/price-guide/:username
	‚Ä¢	Load recipient and min_base_price_usd.
	‚Ä¢	Pull current pending bids to this recipient: select bid_usd from messages where recipient_user_id=$id and status='pending' order by bid_usd.
	‚Ä¢	Winsorize: clamp to [min_base, p95] to remove outliers.
	‚Ä¢	Compute p25 / median / p75; if pending_count < 5, blend 50% with last-7d accepted bids.
	‚Ä¢	Return:

{
  "minBaseUSD":"0.05",
  "p25":"0.08",
  "median":"0.11",
  "p75":"0.18",
  "sampleSize": 23
}

Frontend: show Min / Typical / High quick buttons mapped to minBase, median, p75.

‚∏ª

4) Commit (open bid) + EIP-3009 handshake

POST /api/commit
Body:

{ "recipientUsername":"alice", "content":"Hello!", "bidUsd":"0.50", "replyBountyUsd":null }

4.1 Validate & 402 round-trip
	‚Ä¢	Ensure sender logged in and not blocked by recipient.
	‚Ä¢	Ensure no other pending sender‚Üírecipient (unique partial index helps).
	‚Ä¢	Validate bidUsd >= min_base_price_usd.
	‚Ä¢	If no X-PAYMENT header ‚Üí respond HTTP 402 with payment requirements:

{
  "token":"USDC",
  "chainId":42220,
  "verifyingContract":"<USDC_ADDRESS>",
  "to": "<recipient.wallet_address>",
  "amountMicros": 500000,     // 0.50 USDC -> 500000
  "validAfter": <unixSecondsNow>,
  "validBefore": <now + sla_hours * 3600>,
  "nonce": "<serverGeneratedBytes32>",
  "typedDataDomain": { "name":"USD Coin", "version":"2", "chainId":42220, "verifyingContract":"<USDC_ADDRESS>" },
  "typedDataTypes": { "TransferWithAuthorization":[
    {"name":"from","type":"address"},
    {"name":"to","type":"address"},
    {"name":"value","type":"uint256"},
    {"name":"validAfter","type":"uint256"},
    {"name":"validBefore","type":"uint256"},
    {"name":"nonce","type":"bytes32"}
  ]}
}

(Client signs this typed data; nothing moves on-chain yet.)

4.2 With X-PAYMENT header (second call)

Header:

X-PAYMENT: {
  "from":"0xSender",
  "to":"0xRecipient",
  "value":"500000",
  "validAfter":"<x>",
  "validBefore":"<y>",
  "nonce":"0x...",
  "v":27,"r":"0x...","s":"0x..."
}

Server:
	‚Ä¢	Verify signature against domain/types/values and sender session wallet.
	‚Ä¢	Create messages row: status='pending', expires_at = validBefore (or now + sla_hours if you prefer).
	‚Ä¢	Create payments row with exact parameters + status='authorized'.
	‚Ä¢	Return { messageId, status:"pending", expiresAt }.

üîê Do not store only the signature string; store all parameters you will replay on accept (prevents subtle replay/‚Äúmismatch‚Äù bugs).

‚∏ª

5) Inbox (receiver)

GET /api/inbox
	‚Ä¢	Requires receiver session; return pending items (sorted by bid_usd desc, created_at asc).
	‚Ä¢	Include: messageId, preview, bidUsd, sender.username, senderFacts, expiresAt.

‚∏ª

6) Accept / Decline (settlement)

POST /api/messages/:id/accept
	‚Ä¢	Load message (pending) + payments (authorized).
	‚Ä¢	Row-lock the message: select ... for update to prevent double-accept race.
	‚Ä¢	Call USDC: transferWithAuthorization(from, to, value, validAfter, validBefore, nonce, v, r, s) via viem using your relayer key.
	‚Ä¢	On success:
	‚Ä¢	set payments.status='settled', tx_hash_settle = <hash>, messages.status='accepted', accepted_at=now().
	‚Ä¢	Handle token revert causes (e.g., expired, wrong nonce) ‚Üí mark payments.status='unused', messages.status='expired' or declined' accordingly and surface an error toast.

POST /api/messages/:id/decline
	‚Ä¢	Row-lock; set messages.status='declined', payments.status='unused', declined_at=now().
	‚Ä¢	No on-chain call; funds never moved.

‚∏ª

7) Auto-expiry worker

Cron every 5 minutes:

update messages
  set status='expired'
where status='pending' and expires_at < now()
returning id;

for each message:
  update payments set status='unused' where message_id = id and status='authorized';

Log both sides. (No chain tx required‚Äîauth just becomes invalid after validBefore.)

‚∏ª

8) Security hardening (MVP-critical)
	‚Ä¢	Recipient binding: ensure to == recipient.wallet_address from DB (no payload-swaps).
	‚Ä¢	Replay protection:
	‚Ä¢	Store (nonce, from) in DB; unique index.
	‚Ä¢	USDC contract already tracks used nonces‚Äîyour DB check is an extra guard.
	‚Ä¢	Authorization window: keep validBefore tight (SLA hours). Reject if user tries to reuse old auth.
	‚Ä¢	Bigint math: convert USD ‚Üí USDC microunits once, server-side, with safe integer math.
	‚Ä¢	Blocklist check at composer and commit endpoints.
	‚Ä¢	Rate-limit commit by IP/user to avoid DoS via large pending queues.

‚∏ª

9) Observability
	‚Ä¢	Structured logs: one line per lifecycle step: price_guide_served, payment_authorized, message_pending, message_accepted, message_declined, message_expired, including recipient, bid_usd, latency_ms, wallets, tx_hash.
	‚Ä¢	Metrics dashboards (use any APM):
	‚Ä¢	Pending count per recipient
	‚Ä¢	Acceptance rate 7d
	‚Ä¢	Median accepted bid 7d
	‚Ä¢	Time-to-decision (P50/P90)
	‚Ä¢	Error rates by endpoint

‚∏ª

10) Reputation ‚Äúfacts‚Äù (lightweight)

Nightly job over last 60‚Äì90 days (with exponential decay):
	‚Ä¢	Receivers: acceptance rate, median accepted bid, P90 open time.
	‚Ä¢	Senders: open rate (if you gate full text after accept), decline rate.
Return simple strings to UI (chips on cards), e.g. ‚ÄúAccepts 62% ‚Ä¢ Median $0.11‚Äù.

(Wilson lower bound for rates to avoid small-n lies.)

‚∏ª

11) Manual end-to-end test script

Setup
	‚Ä¢	Two users (two wallets).
	‚Ä¢	Receiver sets min_base_price = $0.05, SLA=24h.

Happy path
	1.	Sender connects wallet ‚Üí compose ‚Äúhi‚Äù ‚Üí price guide appears.
	2.	Choose bid $0.12 ‚Üí POST /api/commit ‚Üí 402 received.
	3.	Wallet signs typed data (EIP-3009) ‚Üí client retries with X-PAYMENT.
	4.	API returns {pending, expiresAt}; /inbox shows item at top.
	5.	Receiver clicks Accept ‚Üí on-chain tx mined ‚Üí UI shows ‚ÄúAccepted‚Äù, balance increments.
	6.	Verify DB: payments.settled, messages.accepted.

Decline
	‚Ä¢	Same until step 4; receiver clicks Decline ‚Üí payments.unused, messages.declined. Verify no chain tx.

Expiry
	‚Ä¢	Create a pending with short SLA (e.g., 2 minutes). Wait ‚Üí worker marks expired & payments.unused.

Guards
	‚Ä¢	Try to accept twice ‚Üí second attempt blocked by row-lock and token‚Äôs authorization state.
	‚Ä¢	Change to or value in replay ‚Üí server rejects (mismatch).
	‚Ä¢	Bid below min ‚Üí server 400.
	‚Ä¢	Blocked sender ‚Üí cannot see price guide / cannot commit.

‚∏ª

12) Frontend wiring notes (React + Wagmi)
	‚Ä¢	Price guide: fetch on username change; show quick buttons: Min / Typical (median) / High (p75).
	‚Ä¢	Commit: first call expects 402; the body gives typed-data domain/types. Use walletClient.signTypedData (wagmi/viem) to sign with the sender account.
	‚Ä¢	Retry: include X-PAYMENT header with all fields (from,to,value,validAfter,validBefore,nonce,v,r,s).
	‚Ä¢	Inbox: poll or use TanStack Query invalidate on accept/decline.

‚∏ª

13) ‚ÄúNice to have‚Äù (quick wins that won‚Äôt complicate MVP)
	‚Ä¢	Withdraw own bid (if still pending & unviewed): mark withdrawn; set payment unused.
	‚Ä¢	Cooldown after decline: require +X% higher next bid within 24h.
	‚Ä¢	Auto-accept threshold (off by default): receiver can set ‚Äúauto-accept ‚â• $T‚Äù.
	‚Ä¢	Reply bounty (phase 2): same EIP-3009 pattern, but escrow separately and settle only on ‚Äúreply‚Äù event.

‚∏ª

14) Launch checklist
	‚Ä¢	‚úÖ Env vars for USDC address, chainId 42220, Forno RPC, relayer private key (accept endpoint).
	‚Ä¢	‚úÖ CORS + HTTPS everywhere.
	‚Ä¢	‚úÖ DB migrations applied; unique indexes in place.
	‚Ä¢	‚úÖ Admin ‚Äúkill-switch‚Äù to disable new commits if RPC degrades.
	‚Ä¢	‚úÖ Clear copy in UI: ‚ÄúNo gas to send. If not accepted in {{SLA}}h, authorization expires and no funds move.‚Äù

‚∏ª

This plan matches your open-bidding, EIP-3009 authorization model exactly: no locked capital, no platform escrow, fully peer-to-peer. If you want, I can also draft the exact Drizzle schemas and a TypeScript helper to build/verify the EIP-3009 typed data so your 402 round-trip is copy-paste ready.